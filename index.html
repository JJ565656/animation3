<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Organic Interference â€” Lattice + Bloom</title>
  <style>
    :root {
      --bg: #F5F1EA;     /* warm beige */
      --ink: rgba(62,58,57,0.35); /* subtle line tone */
      --ink-2: rgba(62,58,57,0.15);
      --neon-a: #C1E11B;  /* neon green core */
      --neon-b: #D7FA1E;  /* neon green highlight */
    }
    html, body { height: 100%; margin: 0; background: var(--bg); }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="scene"></canvas>
  <script>
    // Organic Interference Screensaver
    // - Undulating lattice lines with slight asymmetry
    // - Particle bloom drifting through
    // - Occasional minimal neon-green pulses as accents

    const canvas = document.getElementById('scene');
    const ctx = canvas.getContext('2d');
    const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    function resize(){
      const { innerWidth:w, innerHeight:h } = window;
      canvas.width = Math.floor(w * DPR);
      canvas.height = Math.floor(h * DPR);
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      ctx.setTransform(DPR,0,0,DPR,0,0);
    }
    addEventListener('resize', resize, { passive:true });
    resize();

    // -------- Utilities --------
    const TAU = Math.PI * 2;
    const rand = (a=1,b=0)=> b + (a-b)*Math.random();
    const lerp = (a,b,t)=> a + (b-a)*t;

    // Lightweight 2D value noise (hash-based)
    function hash(x,y){
      let s = Math.sin(x*127.1 + y*311.7) * 43758.5453;
      return s - Math.floor(s);
    }
    function noise2(x,y){
      const xi = Math.floor(x), yi = Math.floor(y);
      const xf = x - xi,   yf = y - yi;
      const tl = hash(xi,yi),    tr = hash(xi+1,yi);
      const bl = hash(xi,yi+1),  br = hash(xi+1,yi+1);
      const u = xf*xf*(3-2*xf);  const v = yf*yf*(3-2*yf);
      const top = tl + (tr - tl)*u;
      const bot = bl + (br - bl)*u;
      return top + (bot - top)*v;
    }

    // -------- Lattice (waves) --------
    const waves = [];
    const WAVE_COUNT = 8; // layered lines
    function initWaves(){
      waves.length = 0;
      for(let i=0;i<WAVE_COUNT;i++){
        waves.push({
          amp: rand(18, 42),
          freq: rand(0.004, 0.010),
          speed: rand(0.3, 0.8),
          phase: rand(0, TAU),
          baseline: i/(WAVE_COUNT-1), // 0..1 vertical placement
          curve: rand(0.6, 1.4), // curvature influence
          tint: i%2===0 ? '--ink' : '--ink-2'
        });
      }
    }
    initWaves();

    // -------- Particles --------
    const particles = [];
    const P_COUNT = 120;
    function initParticles(){
      particles.length = 0;
      const { innerWidth:W, innerHeight:H } = window;
      for(let i=0;i<P_COUNT;i++){
        particles.push({
          x: Math.random()*W,
          y: Math.random()*H,
          r: rand(0.6, 1.8),
          a: rand(0.15, 0.45),
          t: Math.random()*1000, // phase
          neon: Math.random()<0.08 ? rand(0.4,1.2) : 0 // if >0, lifetime seconds
        });
      }
    }
    initParticles();

    // -------- Neon pulses along waves --------
    const pulses = [];
    function spawnPulse(){
      const idx = (Math.random()*waves.length)|0;
      pulses.push({
        i: idx,
        u: Math.random(), // 0..1 along x
        life: rand(1.2, 2.0),
        t: 0,
        s: rand(90, 150) // pixels per second along path
      });
      if(pulses.length>8) pulses.shift();
    }

    let lastTime = performance.now();
    let acc = 0; // for timed events

    function drawFrame(now){
      const dt = Math.min(0.033, (now - lastTime)/1000); // cap delta
      lastTime = now;
      acc += dt;
      if(acc > rand(1.5, 3.5)) { acc = 0; spawnPulse(); }

      const W = innerWidth, H = innerHeight;

      // Clear
      ctx.clearRect(0,0,W,H);

      // Draw lattice waves
      for(let wi=0; wi<waves.length; wi++){
        const wv = waves[wi];
        ctx.beginPath();
        const yBase = H * lerp(0.10, 0.90, wv.baseline);
        for(let x=0; x<=W; x+=6){
          const n = noise2(x*0.01 + wv.phase, now*0.00025*wv.speed);
          const sway = Math.sin(x*wv.freq + now*0.0012*wv.speed + wv.phase);
          const y = yBase + wv.amp * (0.55*sway + 0.45*(n-0.5)*2*wv.curve);
          if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue(wv.tint);
        ctx.lineWidth = 1.25;
        ctx.stroke();
      }

      // Evolve pulses and render on top of the corresponding wave
      for(let p of pulses){
        const wv = waves[p.i];
        p.t += dt;
        p.u += (p.s * dt) / Math.max(1200, W); // progress along width
        if(p.u>1) p.u -= 1; // wrap
        const x = p.u * W;
        const yBase = H * lerp(0.10, 0.90, wv.baseline);
        const n = noise2(x*0.01 + wv.phase, now*0.00025*wv.speed);
        const sway = Math.sin(x*wv.freq + now*0.0012*wv.speed + wv.phase);
        const y = yBase + wv.amp * (0.55*sway + 0.45*(n-0.5)*2*wv.curve);
        // glow
        ctx.save();
        ctx.shadowColor = getCSS('--neon-a');
        ctx.shadowBlur = 12;
        const grad = ctx.createRadialGradient(x,y,0, x,y, 16);
        grad.addColorStop(0, getCSS('--neon-b'));
        grad.addColorStop(1, 'rgba(199, 255, 64, 0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(x,y, 10, 0, TAU);
        ctx.fill();
        ctx.restore();
        // core dot
        ctx.fillStyle = getCSS('--neon-a');
        ctx.beginPath();
        ctx.arc(x,y, 2.2, 0, TAU);
        ctx.fill();
      }

      // Particles
      for(let prt of particles){
        // Velocity field from two sin waves + noise
        const vx = Math.sin((prt.y + now*0.03)*0.006) * 8 + (noise2(prt.x*0.01, prt.y*0.01 + now*0.0002)-0.5) * 12;
        const vy = Math.cos((prt.x - now*0.02)*0.006) * 8 + (noise2(prt.x*0.01 + 100, prt.y*0.01)-0.5) * 12;
        prt.x += vx * dt;
        prt.y += vy * dt;
        prt.t += dt;
        // Wrap
        if(prt.x < -5) prt.x = W+5; else if(prt.x > W+5) prt.x = -5;
        if(prt.y < -5) prt.y = H+5; else if(prt.y > H+5) prt.y = -5;

        // Flicker between base ink and rare neon
        let alpha = prt.a * 0.9;
        let color = `rgba(62,58,57,${alpha})`;
        if(prt.neon > 0){
          const pulse = Math.sin((prt.t*3)%TAU)*0.5+0.5; // 0..1
          color = `rgba(193,225,27,${0.15 + 0.35*pulse})`;
          prt.neon -= dt * 0.25; // slow fade of neon state
          if(prt.neon <= 0 && Math.random()<0.02) prt.neon = rand(0.3,0.8); // rare re-ignite
        } else if(Math.random() < 0.002) {
          prt.neon = rand(0.3,0.9);
        }
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(prt.x, prt.y, prt.r, 0, TAU);
        ctx.fill();
      }

      requestAnimationFrame(drawFrame);
    }

    function getCSS(varName){
      return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
    }

    requestAnimationFrame(drawFrame);
  </script>
</body>
</html>